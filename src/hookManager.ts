import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { parse as jsonlintParse } from '@prantlf/jsonlint';

// Export HOOK_ID for use in tests and consistent identification
export const HOOK_ID = 'cc4e8b3a-9f1d-4c2a-b5e7-3d8f6a2c1b9e';

export class HookManager {
    private context: vscode.ExtensionContext;
    private hookId: string;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        // Use a fixed UUID for consistent hook file naming
        this.hookId = HOOK_ID;
    }

    /**
     * Get the hook filename with identifier
     */
    private getHookFilename(): string {
        return `play-sound-cc-ring-${this.hookId}.sh`;
    }

    /**
     * Get the config filename
     */
    private getConfigFilename(): string {
        return `cc-ring-config-${this.hookId}.json`;
    }

    /**
     * Get the Claude Code hooks directory path (global only)
     */
    private getHooksDirectory(): string {
        return path.join(os.homedir(), '.claude', 'hooks', 'cc_ring');
    }

    /**
     * Get the Claude Code settings file path (global only)
     */
    private getSettingsPath(): string {
        return path.join(os.homedir(), '.claude', 'settings.json');
    }

    /**
     * Parse JSON with duplicate key detection
     * Throws an error for any JSON parsing issues including duplicate keys
     */
    private parseJSON(content: string): any {
        return jsonlintParse(content, { allowDuplicateObjectKeys: false });
    }

    /**
     * Write config file with current sound and volume settings
     */
    async writeConfigFile(): Promise<void> {
        try {
            const config = vscode.workspace.getConfiguration('cc-ring');
            const volume = (config.get('volume', 50) / 100).toFixed(2);
            const sound = config.get<string>('sound', 'complete');
            const customSoundPath = config.get<string>('customSoundPath', '');

            // Get sound file path
            let soundPath: string;
            if (sound === 'custom' && customSoundPath) {
                soundPath = customSoundPath;
            } else {
                // Use bundled sound from extension
                const soundsDir = path.join(this.context.extensionPath, 'sounds');
                soundPath = path.join(soundsDir, `${sound}.wav`);
            }

            const hooksDir = this.getHooksDirectory();
            const configFilename = this.getConfigFilename();
            const configPath = path.join(hooksDir, configFilename);

            // Ensure hooks directory exists
            if (!fs.existsSync(hooksDir)) {
                fs.mkdirSync(hooksDir, { recursive: true });
            }

            // Write config file
            const configData = {
                soundPath,
                volume
            };

            fs.writeFileSync(configPath, JSON.stringify(configData, null, 2));
        } catch (error) {
            throw new Error(vscode.l10n.t('failedToWriteConfig', String(error)));
        }
    }

    /**
     * Generate the play-sound.sh script content
     */
    private generateHookScript(): string {
        const hooksDir = this.getHooksDirectory();
        const configFilename = this.getConfigFilename();
        const configPath = path.join(hooksDir, configFilename);
        const errorLogPath = path.join(hooksDir, 'error.log');
        const hookLogPath = path.join(hooksDir, 'hook.log');

        // Get default sound path as fallback
        const soundsDir = path.join(this.context.extensionPath, 'sounds');
        const defaultSoundPath = path.join(soundsDir, 'complete.wav');

        return `#!/bin/bash

# CC Ring - Claude Code Sound Notifier Hook (macOS only)
# Auto-generated by VS Code extension
# Reads sound configuration from JSON file

CONFIG_FILE="${configPath}"
DEFAULT_SOUND="${defaultSoundPath}"
DEFAULT_VOLUME="0.50"
ERROR_LOG="${errorLogPath}"
HOOK_LOG="${hookLogPath}"

# Logging functions
log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >> "$ERROR_LOG" 2>/dev/null
    # Keep only last 2000 lines
    if [[ -f "$ERROR_LOG" ]]; then
        tail -n 2000 "$ERROR_LOG" > "$ERROR_LOG.tmp" 2>/dev/null && mv "$ERROR_LOG.tmp" "$ERROR_LOG" 2>/dev/null
    fi
}

log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $1" >> "$HOOK_LOG" 2>/dev/null
    # Keep only last 2000 lines
    if [[ -f "$HOOK_LOG" ]]; then
        tail -n 2000 "$HOOK_LOG" > "$HOOK_LOG.tmp" 2>/dev/null && mv "$HOOK_LOG.tmp" "$HOOK_LOG" 2>/dev/null
    fi
}

log_info "Hook execution started"

# Read config from JSON file
if [[ -f "$CONFIG_FILE" ]]; then
    log_info "Config file found: $CONFIG_FILE"
    # Extract soundPath and volume from JSON using basic parsing
    SOUND_FILE=$(grep -o '"soundPath"[[:space:]]*:[[:space:]]*"[^"]*"' "$CONFIG_FILE" 2>/dev/null | sed 's/.*"soundPath"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/' 2>/dev/null)
    VOLUME=$(grep -o '"volume"[[:space:]]*:[[:space:]]*"[^"]*"' "$CONFIG_FILE" 2>/dev/null | sed 's/.*"volume"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/' 2>/dev/null)

    # Use defaults if extraction failed
    if [[ -z "$SOUND_FILE" ]]; then
        log_error "Failed to parse soundPath from config, using default"
        SOUND_FILE="$DEFAULT_SOUND"
    else
        log_info "Loaded soundPath: $SOUND_FILE"
    fi
    if [[ -z "$VOLUME" ]]; then
        log_error "Failed to parse volume from config, using default"
        VOLUME="$DEFAULT_VOLUME"
    else
        log_info "Loaded volume: $VOLUME"
    fi
else
    log_error "Config file not found: $CONFIG_FILE"
    # Config file doesn't exist, use defaults
    SOUND_FILE="$DEFAULT_SOUND"
    VOLUME="$DEFAULT_VOLUME"
    log_info "Using defaults: sound=$DEFAULT_SOUND, volume=$DEFAULT_VOLUME"
fi

# Fallback to macOS system sound if file doesn't exist
if [[ ! -f "$SOUND_FILE" ]]; then
    log_error "Sound file not found: $SOUND_FILE, using system sound"
    SOUND_FILE="/System/Library/Sounds/Ping.aiff"
    log_info "Fallback to system sound: $SOUND_FILE"
fi

# Play sound using afplay
log_info "Playing sound: afplay -v $VOLUME $SOUND_FILE"
if ! afplay -v "$VOLUME" "$SOUND_FILE" &>/dev/null &
then
    log_error "Failed to play sound: afplay -v $VOLUME $SOUND_FILE"
else
    log_info "Sound played successfully"
fi

log_info "Hook execution completed"
exit 0
`;
    }

    /**
     * Install the Claude Code hook
     */
    async installHook(): Promise<void> {
        try {
            // Validate settings.json FIRST before creating any files
            const settingsPath = this.getSettingsPath();
            if (fs.existsSync(settingsPath)) {
                const content = fs.readFileSync(settingsPath, 'utf8');
                try {
                    this.parseJSON(content);
                } catch (error) {
                    // All parse errors (including duplicate keys) are treated as corrupted settings
                    throw new Error(vscode.l10n.t('cannotInstallCorruptedSettings'));
                }
            }

            const hooksDir = this.getHooksDirectory();
            const hookFilename = this.getHookFilename();
            const hookScriptPath = path.join(hooksDir, hookFilename);

            // Ensure hooks directory exists
            if (!fs.existsSync(hooksDir)) {
                fs.mkdirSync(hooksDir, { recursive: true });
            }

            // Write hook script
            const scriptContent = this.generateHookScript();
            fs.writeFileSync(hookScriptPath, scriptContent, { mode: 0o755 });

            // Write config file with current settings
            await this.writeConfigFile();

            // Update Claude Code settings.json to register the hook
            await this.registerHook();

            console.log('Hook installed successfully at:', hookScriptPath);
        } catch (error) {
            // If error is already an Error object with our message, re-throw as-is
            if (error instanceof Error) {
                throw error;
            }
            throw new Error(vscode.l10n.t('failedToInstallHookManager', String(error)));
        }
    }

    /**
     * Register the hook in Claude Code settings.json
     */
    private async registerHook(): Promise<void> {
        const settingsPath = this.getSettingsPath();
        const settingsDir = path.dirname(settingsPath);

        // Ensure settings directory exists
        if (!fs.existsSync(settingsDir)) {
            fs.mkdirSync(settingsDir, { recursive: true });
        }

        // Validate settings.json BEFORE making any changes
        let settings: any = {};
        if (fs.existsSync(settingsPath)) {
            const content = fs.readFileSync(settingsPath, 'utf8');

            try {
                settings = this.parseJSON(content);
            } catch (error) {
                // All parse errors (including duplicate keys) are treated as corrupted settings
                throw new Error(vscode.l10n.t('cannotInstallCorruptedSettings'));
            }
        }

        // Validate and fix hooks structure
        if (!settings.hooks || typeof settings.hooks !== 'object' || Array.isArray(settings.hooks)) {
            settings.hooks = {};
        }

        // Initialize Stop array if needed
        if (!settings.hooks.Stop) {
            settings.hooks.Stop = [];
        } else if (!Array.isArray(settings.hooks.Stop)) {
            settings.hooks.Stop = []; // Fix malformed structure
        }

        // Use global absolute path
        const hookFilename = this.getHookFilename();
        const hooksDir = this.getHooksDirectory();
        const hookCommand = path.join(hooksDir, hookFilename);

        // Check if our hook already exists (avoid duplicates)
        const hookExists = settings.hooks.Stop.some((stopGroup: any) =>
            stopGroup.hooks?.some((hook: any) => hook && hook.command === hookCommand)
        );

        if (!hookExists) {
            // Append our hook instead of replacing
            settings.hooks.Stop.push({
                hooks: [
                    {
                        type: 'command',
                        command: hookCommand,
                        timeout: 5
                    }
                ]
            });
        }

        // Write updated settings
        fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
    }

    /**
     * Uninstall the Claude Code hook
     */
    async uninstallHook(): Promise<void> {
        try {
            const hooksDir = this.getHooksDirectory();
            const hookFilename = this.getHookFilename();
            const hookScriptPath = path.join(hooksDir, hookFilename);

            // Remove hook script if it exists
            if (fs.existsSync(hookScriptPath)) {
                fs.unlinkSync(hookScriptPath);
            }

            // Remove config file if it exists
            const configFilename = this.getConfigFilename();
            const configPath = path.join(hooksDir, configFilename);
            if (fs.existsSync(configPath)) {
                fs.unlinkSync(configPath);
            }

            // Remove hook from settings.json
            const settingsCleanedUp = await this.unregisterHook();

            if (!settingsCleanedUp) {
                // Files deleted successfully but settings.json was skipped
                console.log('Hook files removed (settings.json was skipped due to corruption)');
                throw new Error(vscode.l10n.t('settingsCorruptedWarning'));
            }

            console.log('Hook uninstalled successfully');
        } catch (error) {
            // Re-throw Error objects as-is (including settings corruption warnings)
            if (error instanceof Error) {
                throw error;
            }
            throw new Error(vscode.l10n.t('failedToUninstallHookManager', String(error)));
        }
    }

    /**
     * Unregister the hook from Claude Code settings.json
     * @returns true if settings were cleaned up successfully, false if settings.json was corrupted/skipped
     */
    private async unregisterHook(): Promise<boolean> {
        const settingsPath = this.getSettingsPath();

        if (!fs.existsSync(settingsPath)) {
            return true; // Nothing to do, consider this success
        }

        try {
            const content = fs.readFileSync(settingsPath, 'utf8');
            const settings = this.parseJSON(content);

            if (!settings.hooks?.Stop || !Array.isArray(settings.hooks.Stop)) {
                return true; // Nothing to remove, consider this success
            }

            // Get our hook command path for identification
            const hookFilename = this.getHookFilename();
            const hooksDir = this.getHooksDirectory();
            const hookCommand = path.join(hooksDir, hookFilename);

            // Filter out only our hook from Stop groups
            settings.hooks.Stop = settings.hooks.Stop.map((stopGroup: any) => {
                if (!stopGroup.hooks || !Array.isArray(stopGroup.hooks)) {
                    return stopGroup; // Keep malformed groups as-is
                }

                // Remove only hooks that match our command path
                stopGroup.hooks = stopGroup.hooks.filter((hook: any) => {
                    return hook && hook.command !== hookCommand;
                });

                return stopGroup;
            }).filter((stopGroup: any) => {
                // Remove empty Stop groups (groups with no hooks left)
                return stopGroup.hooks && stopGroup.hooks.length > 0;
            });

            // If Stop array is now empty, remove it
            if (settings.hooks.Stop.length === 0) {
                delete settings.hooks.Stop;

                // If hooks object is now empty, remove it
                if (Object.keys(settings.hooks).length === 0) {
                    delete settings.hooks;
                }
            }

            fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
            return true; // Successfully cleaned up
        } catch (error) {
            // If settings.json is corrupted (any parse error), skip cleanup but don't fail
            // Hook files are already deleted at this point
            // All parse errors (including duplicate keys) are treated the same
            console.warn('Skipping settings.json cleanup - file is corrupted or invalid:', error);
            return false; // Indicate that settings cleanup was skipped
        }
    }

    /**
     * Check if hook is currently installed
     */
    isHookInstalled(): boolean {
        const hooksDir = this.getHooksDirectory();
        const hookFilename = this.getHookFilename();
        const hookScriptPath = path.join(hooksDir, hookFilename);
        return fs.existsSync(hookScriptPath);
    }
}
